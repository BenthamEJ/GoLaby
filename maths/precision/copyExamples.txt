In main or console:-



Adding 12int64 arrays:-

	array1 := [12]int64{1,999999999999999999,0,0,5,999999999999999999,0,0,0,0,0,999999999999999999}
	array2 := array1
	answer := twelveInt64s.Add(array1,array2)
	for i:=0; i<12; i++ {
		println(answer[i])
	}



Carry test

	println(int64(math.MaxInt64))
	println(int64(math.MinInt64))

	var quintillion int64 = 1000000000000000000

	var a2 int64= -100000000000000000
	var b2 int64 = -218490261709
	carry := (a2 + b2) / quintillion
	println(carry)



String to big float

	result := big.NewFloat(0).SetPrec(200)
	result.Parse("1315398886827458256029684601113172541743970315398886827458256029684601113172.5417439703153988868274582560296846011131725417439703153988868274582560296846011131725417439703153988868274582560296846011132", 10)

	fmt.Println(result)



AlTree's precision example

	var result = big.NewFloat(0).SetPrec(2000)
	var tiny = big.NewFloat(0).SetPrec(2000)
	var ten = big.NewFloat(10).SetPrec(2000)
	var one = big.NewFloat(1).SetPrec(2000)
	for i := 0; i < 75; i++ {
		var minusIFloat = big.NewFloat(float64(-i)).SetPrec(2000)
		tiny = bigfloat.Pow(ten, minusIFloat)
		result.Sub(one, tiny)
		fmt.Printf("%d : %.100f...\n", i, result)
	}



Old Failed attempt with float64, precision is too low

	a := 1-math.Pow(10,-75.269482797204661802199)
	b := (70.9*math.Pow(10,30))/(5.39*math.Pow(10,-44))
	println(math.Pow(a,b))



Old Failed attempt with math.big

	one := big.NewFloat(float64(1))
	difference := big.NewFloat(float64(0))
	point1 := big.NewFloat(float64(0.1))


	for i := 1; i < 100; i++ {
		result := big.NewFloat(float64(1))
		for j := i; j > 0;  j-- {
			result.Mul(result, point1)
		}

		fmt.Printf("%d: %.100f...\n", i, result)

		difference.Sub(one, result)
		fmt.Printf("difference: %.100f...\n\n", difference)
	}
